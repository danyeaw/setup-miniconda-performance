name: Main Performance Test

on:
  workflow_dispatch:
    inputs:
      test-suite:
        description: 'Which test suite to run'
        required: true
        default: 'all'
        type: choice
        options:
          - all
          - core-setup-comparison
          - environment-operations
          - caching-performance
          - solver-optimization
          - lockfile-performance
          - shell-performance
          - channel-performance
      generate-summary:
        description: 'Generate summary report after tests'
        required: false
        default: true
        type: boolean
  push:
    branches: [ main ]
    paths: [ '.github/workflows/main-performance-test.yml' ]

permissions:
  actions: write
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  trigger-tests:
    name: Trigger Performance Tests
    runs-on: ubuntu-latest
    outputs:
      triggered-workflows: ${{ steps.trigger.outputs.workflows }}
      trigger-time: ${{ steps.trigger.outputs.trigger-time }}
    steps:
      - name: Trigger Selected Tests
        id: trigger
        uses: actions/github-script@v7
        with:
          script: |
            const testSuite = '${{ github.event.inputs.test-suite }}' || 'all';
            
            const workflows = {
              'core-setup-comparison': 'core-setup-comparison.yml',
              'environment-operations': 'environment-operations.yml', 
              'caching-performance': 'caching-performance.yml',
              'solver-optimization': 'solver-optimization.yml',
              'lockfile-performance': 'lockfile-performance.yml',
              'shell-performance': 'shell-performance.yml',
              'channel-performance': 'channel-performance.yml'
            };
            
            const triggeredWorkflows = [];
            const triggerTime = new Date().toISOString();
            
            if (testSuite === 'all') {
              // Trigger all workflows
              for (const [name, workflowFile] of Object.entries(workflows)) {
                try {
                  await github.rest.actions.createWorkflowDispatch({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    workflow_id: workflowFile,
                    ref: 'main'
                  });
                  triggeredWorkflows.push(name);
                  console.log(`âœ… Triggered ${name}`);
                } catch (error) {
                  console.log(`âŒ Failed to trigger ${name}: ${error.message}`);
                }
            
                // Add delay between triggers to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 2000));
              }
            } else if (workflows[testSuite]) {
              // Trigger specific workflow
              try {
                await github.rest.actions.createWorkflowDispatch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: workflows[testSuite],
                  ref: 'main'
                });
                triggeredWorkflows.push(testSuite);
                console.log(`âœ… Triggered ${testSuite}`);
              } catch (error) {
                console.log(`âŒ Failed to trigger ${testSuite}: ${error.message}`);
              }
            } else {
              console.log(`âŒ Unknown test suite: ${testSuite}`);
            }
            
            core.setOutput('workflows', JSON.stringify(triggeredWorkflows));
            core.setOutput('trigger-time', triggerTime);
            return triggeredWorkflows;

      - name: Display Triggered Tests
        run: |
          echo "=== TRIGGERED PERFORMANCE TESTS ==="
          echo "Test Suite: ${{ github.event.inputs.test-suite || 'all' }}"
          echo "Triggered Workflows: ${{ steps.trigger.outputs.workflows }}"
          echo "Trigger Time: ${{ steps.trigger.outputs.trigger-time }}"
          echo ""
          echo "You can monitor the progress of these tests in the Actions tab:"
          echo "https://github.com/${{ github.repository }}/actions"

  wait-and-summarize:
    name: Wait for Tests and Generate Summary
    runs-on: ubuntu-latest
    needs: [trigger-tests]
    if: ${{ github.event.inputs.generate-summary != 'false' }}
    steps:
      - name: Smart Wait for Tests to Complete
        id: smart-wait
        uses: actions/github-script@v7
        with:
          script: |
            const triggeredWorkflows = JSON.parse('${{ needs.trigger-tests.outputs.triggered-workflows }}');
            const triggerTime = new Date('${{ needs.trigger-tests.outputs.trigger-time }}');
            
            const workflowFiles = {
              'core-setup-comparison': 'core-setup-comparison.yml',
              'environment-operations': 'environment-operations.yml', 
              'caching-performance': 'caching-performance.yml',
              'solver-optimization': 'solver-optimization.yml',
              'lockfile-performance': 'lockfile-performance.yml',
              'shell-performance': 'shell-performance.yml',
              'channel-performance': 'channel-performance.yml'
            };
            
            const pollInterval = 60000; // Poll every 60 seconds
            const maxWaitTime = 30 * 60 * 1000; // Maximum 30 minutes
            const startTime = Date.now();
            
            console.log(`Waiting for ${triggeredWorkflows.length} workflows to complete...`);
            console.log(`Workflows: ${triggeredWorkflows.join(', ')}`);
            console.log(`Looking for runs after: ${triggerTime.toISOString()}`);
            
            // Give workflows time to start
            console.log('â³ Initial 60s wait for workflows to start...');
            await new Promise(resolve => setTimeout(resolve, 60000));
            
            while (Date.now() - startTime < maxWaitTime) {
              const results = {};
              let allCompleted = true;
              let anyRunning = false;
            
              for (const workflowName of triggeredWorkflows) {
                const workflowFile = workflowFiles[workflowName];
                if (!workflowFile) continue;
            
                try {
                  // Get recent runs without event filtering (API delay issue)
                  const runs = await github.rest.actions.listWorkflowRuns({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    workflow_id: workflowFile,
                    per_page: 20
                  });
            
                  // Look for runs that started around our trigger time (within 5 minutes)
                  const recentRun = runs.data.workflow_runs.find(run => {
                    const runTime = new Date(run.created_at);
                    const timeDiff = Math.abs(runTime - triggerTime);
                    return timeDiff < 5 * 60 * 1000; // Within 5 minutes
                  });
            
                  if (recentRun) {
                    results[workflowName] = {
                      status: recentRun.status,
                      conclusion: recentRun.conclusion,
                      html_url: recentRun.html_url,
                      created_at: recentRun.created_at,
                      run_number: recentRun.run_number
                    };
            
                    if (recentRun.status === 'in_progress' || recentRun.status === 'queued') {
                      allCompleted = false;
                      anyRunning = true;
                    } else if (recentRun.status !== 'completed') {
                      allCompleted = false;
                    }
                  } else {
                    results[workflowName] = { status: 'not_found' };
                    allCompleted = false;
                  }
                } catch (error) {
                  console.log(`Error checking ${workflowName}: ${error.message}`);
                  results[workflowName] = { status: 'error', error: error.message };
                  allCompleted = false;
                }
              }
            
              // Log current status
              const elapsed = Math.round((Date.now() - startTime) / 1000);
              console.log(`\nâ±ï¸  Elapsed: ${elapsed}s`);
            
              for (const [name, result] of Object.entries(results)) {
                let status;
                if (result.status === 'completed') {
                  status = `âœ… ${result.conclusion}`;
                } else if (result.status === 'in_progress') {
                  status = `ðŸ”„ running`;
                } else if (result.status === 'queued') {
                  status = `â³ queued`;
                } else if (result.status === 'not_found') {
                  status = `â“ not found`;
                } else if (result.status === 'error') {
                  status = `âŒ error`;
                } else {
                  status = `â“ ${result.status}`;
                }
            
                const runInfo = result.run_number ? ` (#${result.run_number})` : '';
                console.log(`  ${name}${runInfo}: ${status}`);
              }
            
              if (allCompleted) {
                console.log(`\nðŸŽ‰ All workflows completed after ${elapsed}s!`);
                core.setOutput('results', JSON.stringify(results));
                core.setOutput('all_completed', 'true');
                core.setOutput('wait_time', elapsed);
                return results;
              }
            
              // Check if we have found some workflows but none are running after reasonable time
              const foundWorkflows = Object.values(results).filter(r => r.status !== 'not_found' && r.status !== 'error');
              if (foundWorkflows.length === 0 && elapsed > 300) {
                console.log(`\nâš ï¸  No workflows found after ${elapsed}s`);
                console.log('This might indicate a workflow dispatch issue or timing problem');
              }
            
              // Wait before next poll
              console.log(`\nðŸ’¤ Waiting ${pollInterval/1000}s before next check...`);
              await new Promise(resolve => setTimeout(resolve, pollInterval));
            }
            
            // Timeout reached
            const elapsed = Math.round((Date.now() - startTime) / 1000);
            console.log(`\nâ° Timeout reached after ${elapsed}s`);
            console.log('Some workflows may still be running');
            
            const results = {};
            for (const workflowName of triggeredWorkflows) {
              if (!results[workflowName]) {
                results[workflowName] = { status: 'timeout' };
              }
            }
            
            core.setOutput('results', JSON.stringify(results));
            core.setOutput('all_completed', 'false');
            core.setOutput('wait_time', elapsed);
            core.setOutput('timeout', 'true');
            
            return results;

      - name: Generate Quick Summary
        env:
          TEST_RESULTS: ${{ steps.smart-wait.outputs.results }}
        run: |
          echo "=== PERFORMANCE TEST SUMMARY ===" 
          echo ""
          echo "**Triggered at:** ${{ needs.trigger-tests.outputs.trigger-time }}"
          echo "**Test Suite:** ${{ github.event.inputs.test-suite || 'all' }}"
          echo "**Wait Time:** ${{ steps.smart-wait.outputs.wait_time }}s"
          echo ""
          echo "## Test Status"
          echo ""
          
          # Parse and display results
          echo '${{ steps.smart-wait.outputs.results }}' | jq -r '
            to_entries[] |
            "- **" + .key + "**: " + 
            (if .value.status == "completed" then 
              (.value.conclusion // "unknown")
            else 
              (.value.status // "unknown")
            end) +
            (if .value.html_url then " ([View](" + .value.html_url + "))" else "" end) +
            (if .value.run_number then " (#" + (.value.run_number | tostring) + ")" else "" end)
          '
          
          echo ""
          if [ "${{ steps.smart-wait.outputs.all_completed }}" = "true" ]; then
            echo "âœ… All tests completed in ${{ steps.smart-wait.outputs.wait_time }}s!"
            echo ""
            echo "Performance summary will be generated automatically..."
          elif [ "${{ steps.smart-wait.outputs.timeout }}" = "true" ]; then
            echo "â° Timeout reached after ${{ steps.smart-wait.outputs.wait_time }}s"
            echo ""
            echo "Some tests may still be running. Check the Actions tab:"
            echo "https://github.com/${{ github.repository }}/actions"
            echo ""
            echo "You can run the summary manually once tests complete:"
            echo "gh workflow run performance-summary.yml"
          else
            echo "â³ Some tests are still running or haven't started yet."
            echo ""
            echo "Check the Actions tab for real-time status:"
            echo "https://github.com/${{ github.repository }}/actions"
          fi

      - name: Trigger Summary Report
        if: steps.smart-wait.outputs.all_completed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            // Wait a bit more to ensure all artifacts are ready
            console.log('â³ Waiting 30s for artifacts to be ready...');
            await new Promise(resolve => setTimeout(resolve, 30000));
            
            console.log('ðŸš€ Triggering Performance Summary workflow...');
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'performance-summary.yml',
              ref: 'main'
            });
            console.log('âœ… Performance Summary workflow triggered!');
